<!--
Script:   Desktop Cleaner
Author:   Elias Fotinis
Descr:    Moves desktop items to a unique folder created for each day.
History:  2005.03.25  Created.
          2005.04.09  Fixed moving directories across drives, by manually traversing folders and moving files one by one.
-->
<job id="EFDesktopCleaner">
  <script language="JScript">


    /****** USER SETTINGS BEGIN *******/

    // The directory to send the desktop items to.
    // It will be created if it doesn't exist.
    var TARGET_DIR = "F:\\docs\\todo\\desktop stuff"

    // The names of files and directories that should not be moved.
    // Extension must be specified; dir path must not.
    // e.g. new Array("myfile.txt", "Projects Folder")
    var IGNORE_LIST = new Array("todo", "desktop cleaner.wsf.lnk", "DXBall2.lnk", "Halo.lnk", "Nero.lnk");

    /****** USER SETTINGS END *******/


    var SCRIPT_NAME = "Desktop Cleaner";
    var ERR_FILE_ALREADY_EXISTS = -2146828230;


    // ------------------------
    // Return a string representation of number 'x', padded with zeroes to reach the specified length.
    // If the specified length is too small to represent the whole number, the number is not truncuated.
    // ------------------------
    function PadZero(n, strLen) {
      var s = n.toString();
      while (s.length < strLen)
        s = "0" + s;
      return s;
    }


    // ------------------------
    // Create all the folder levels in the specified path. Existing folders do not cause failure.
    // E.g. if "C:\Test\foo\bar" is specified and only "C:\Temp" exists, both "foo" and "bar" are created.
    // There's no rollback on partial success.
    //    FileSystemObject  fso   
    //    string            s     The full path of the folder.
    // Returns the Folder object of the deepest folder if all where created, or null otherwise.
    // ------------------------
    function CreateDeepFolder(fso, s) {
      var tokens = s.split("\\");
      // remove empty tokens
      for (var i = tokens.length - 1; i >= 0; --i)
        if (tokens[i] == "")
          tokens.splice(i, 1);
      // make sure there's something
      if (tokens.length == 0)
        return null;
      try {
        // get the root of the drive first (this is the only statement in this 'try' block that may throw)
        var curFolder = fso.GetDrive(tokens[0]).RootFolder;
        for (var i = 1; i < tokens.length; ++i) {
          curFolder = GetSubFolder(fso, curFolder, tokens[i], true);
          if (!curFolder)
            return null;
        }
        return curFolder;
      }
      catch (x) {
        return null;
      }
      /*
      //if (s.length == 0)
      //  return false;
      //if (s.charAt(s.length - 1) == "\\")
      //  s = s.substr(0, s.length - 1);
      var beg = 0;
      for (;;) {
        var i = s.indexOf("\\", beg);
        var curPath = i == -1 ? s : s.substr(0, i);
        var isRoot = curPath.length > 0 && curPath.charAt(curPath.length - 1) == ":";
        if (!isRoot) { // don't try to create a root dir (although it succeeds on the sys drive!?!?)
          try {
            fso.CreateFolder(curPath);
          }
          catch (e) {
            if (e.number != ERR_FILE_ALREADY_EXISTS) {
              return false;  // failed
            }
          }
        }
        if (i == -1)
          return true;  // no more dirs; return success
        else
          beg = i + 1;  // prepare for next iteration
      }
      */
    }


    // ------------------------
    // Return a string from the passed date, to be used as a dir name.
    // You can change this to your preferred date format.
    // ------------------------
    function GetDateStr(d) {
      return d.getFullYear() + "." + PadZero(d.getMonth() + 1, 2) + "." + PadZero(d.getDate(), 2);
    }


    // Create an object that can be used to generate unique alternate names of a file.
    // Example:
    //    var nameGen = new AltNameGen("foo.txt");
    //    for (var n = 0; n < 3; ++n)
    //      alert(nameGen.Next());
    // the above will output these names:
    //    "foo.txt", "foo (2).txt", "foo (3).txt"
    //
    function AltNameGen(name) {
      // We initially store the whole name in 'base' and defer 
      // the base/ext splitting for the 2nd call of Next().
      this.base = name;
      this.ext = "";
      this.baseIndexSep = "";
      this.index = 0;
      this.Next = function() {
        switch (++this.index) {
          case 1:
            // on the first call, just return the original name, which is still in 'base'
            return this.base;
          case 2: {
            // on the second call, first split the base and extension
            // and then return a unique name
            var i = this.base.lastIndexOf(".");
            if (i != -1) {
              this.ext  = this.base.substr(i);
              this.base = this.base.substr(0, i)
            }
            if (this.base != "")
              this.baseIndexSep = " ";
            break;
          }
        }
        // 'baseIndexSep' is "" if 'base' is "", in order to avoid the leading space in the generated name;
        // otherwise, 'baseIndexSep' is " "
        return this.base + this.baseIndexSep + "(" + this.index + ")" + this.ext;
      }
    }


    // ------------------------
    // Try to move a File item to 'targetDir'.
    // Returns success and updates 'errors'.
    // Will try to rename the item, if there's a collision.
    // ------------------------
    function TryItemMove(fso, /*File*/ item, /*string*/ targetDir, /*Status*/ status) {
      var nameGen = new AltNameGen(item.Name);
      for (;;) {
        try {
          item.Move(fso.BuildPath(targetDir, nameGen.Next()));
          return true;
        }
        catch (x) {
          if (x.number == ERR_FILE_ALREADY_EXISTS)
            continue; // try again with a different name
          else {
            // unexpected error; fail
            status.addError("Could not move " + item.Name + ": " + x.description + " (" + x.number + ")");
            return false;
          }
        }
      }
    }


    // ------------------------
    // Check whether the specified item is in the ignore-list.
    // ------------------------
    function IsIgnoredItem(ingoreList, name) {
      var nameUC = name.toUpperCase();
      for (var i in ingoreList)
        if (nameUC == ingoreList[i])
          return true;
      return false;
    }


    // ------------------------
    // Create a status object.
    // ------------------------
    function Status() {
      this.moved = 0;
      this.failed = 0;
      this.ignored = 0;
      this.errors = "";
      this.addError = function(s) {
        this.errors += s + "\n";
      }
    }
    

    /*
    // ------------------------
    // Process an item and update the status counters.
    // ------------------------
    function ProcessItem(item, targetDir, status) {
      if (IsIgnoredItem(item.name))
        ++status.ignored;
      else if (TryItemMove(item, targetDir, status))
        ++status.moved;
      else
        ++status.failed;
    }*/


    function main() {
      var wssh = WScript.CreateObject("WScript.Shell");
      var fso = new ActiveXObject("Scripting.FileSystemObject");

      // make all excepted names uppercase, since IsIgnoredItem() has to be case-insensitive
      for (var i = 0; i < IGNORE_LIST.length; ++i)
        IGNORE_LIST[i] = IGNORE_LIST[i].toUpperCase();

      // build target dir name
      var curDate = new Date;
      var targetDir = fso.BuildPath(TARGET_DIR, GetDateStr(curDate));

      // confirm script run
      var MB_OKCANCEL = 1;
      var IDOK = 1;
      if (wssh.Popup("Move desktop files to \"" + targetDir + "\"?", 0, SCRIPT_NAME, 1) != IDOK)
        return;
        
      // get src folder
      var srcFolder = fso.GetFolder(wssh.SpecialFolders.Item("Desktop"));

      // get/create dst folder
      var dstFolder = CreateDeepFolder(fso, targetDir);
      if (!dstFolder) {
        WScript.Echo("Could not create target dir:", targetDir);
        return;
      }

      var status = new Status;

      
      MoveFolderContents(fso, srcFolder, dstFolder, status, IGNORE_LIST);
      
      
      /*
      // enumerate & move desktop files/dirs
      for (var e = new Enumerator(desktop.Files); !e.atEnd(); e.moveNext())
        ProcessItem(e.item(), targetDir, status);
      for (var e = new Enumerator(desktop.SubFolders); !e.atEnd(); e.moveNext())
        ProcessItem(e.item(), targetDir, status);

      var msg = "Directories\r\n" + 
                "Source:\t" + desktop + "\r\n" + 
                "Target:\t" + targetDir + "\r\n" + 
                "\r\n" + 
                "Items\r\n" + 
                "Moved:\t" + status.moved + "\r\n" + 
                "Ignored:\t" + status.ignored + "\r\n" + 
                "Failed:\t" + status.failed;
      if (status.failed != 0)
        msg += "\r\n\r\nFailed items\r\n" + status.errors;

      */

      WScript.Echo(status.errors ? status.errors : "Done");
      
    }


    main();
    

    function MoveFolderContents(fso, srcFolder, dstFolder, status, exceptions) {
      // first move the files
      for (var e = new Enumerator(srcFolder.Files); !e.atEnd(); e.moveNext()) {
        var file = e.item();
        if (exceptions && IsIgnoredItem(exceptions, file.Name))
          ;
        else if (TryItemMove(fso, file, dstFolder.Path, status))
          ;
        else
          ;
      }
        
      // then move the subfolders
      for (var e = new Enumerator(srcFolder.SubFolders); !e.atEnd(); e.moveNext()) {
        var srcSubfolder = e.item();
        if (exceptions && IsIgnoredItem(exceptions, srcSubfolder.Name))
          continue;
        
        var dstSubfolder = GetSubFolder(fso, dstFolder, srcSubfolder.Name, true); // get/create dst subfolder
        if (dstSubfolder) {
          MoveFolderContents(fso, srcSubfolder, dstSubfolder, status); // don't pass 'exceptions' on recursive calls
          if (srcSubfolder.Files.Count == 0 && srcSubfolder.SubFolders.Count == 0) {
            if (!TryFolderDelete(srcSubfolder)) {
              status.addError("Could not delete " + srcSubfolder.Path);
            }
          }
        }
      }
    }

    
    // Get a subfolder of an existing folder.
    // Optionally create the subfolder if it does not exist.
    //    FileSystemObject fso      
    //    Folder           parent   The parent folder.
    //    string           name     The name of the subfolder.
    //   [boolean          create]  Whether to create the subfolder.
    // Return Folder object of the subfolder or null.
    function GetSubFolder(fso, parent, name, create) {
      try {
        var path = fso.BuildPath(parent, name);
        if (!create || fso.FolderExists(path))
          return fso.GetFolder(path);
        else
          return fso.CreateFolder(path);  // will fail if there's a file with the same name
      }
      catch (x) {
        return null;
      }
    }


    function TryFolderDelete(folder) {
      try {
        folder.Delete();
        return true;
      }
      catch (x) {
        return false;
      }
    }


  </script>
</job>
